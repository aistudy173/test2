"""
Java Metadata Hierarchical Extractor (Python, Tree-sitter version)

This script uses `tree-sitter` with the Java grammar to parse Java source
files and extract a hierarchical representation of types (classes,
interfaces, enums, records), their fields, constructors, methods, and nested types.
Output is emitted in Markdown by default.

Requirements:
- Python 3.8+
- pip install tree-sitter tree-sitter-java

Usage:
    python java_metadata_extractor.py input.java -o output.md

Note: Tree-sitter gives raw parse trees, not semantic AST nodes like
`javalang`. This implementation walks the tree and extracts class,
method, and field metadata heuristically.
"""
import argparse
import sys
from typing import List
from tree_sitter import Language, Parser

# Load Java grammar (tree-sitter-java must be installed)
Language.build_library(
    'build/my-languages.so',
    [
        'tree-sitter-java'
    ]
)

JAVA_LANGUAGE = Language('build/my-languages.so', 'java')
parser = Parser()
parser.set_language(JAVA_LANGUAGE)


def read_file(path: str) -> str:
    with open(path, "r", encoding="utf-8") as f:
        return f.read()


# ------------------------ Tree Walkers -------------------------------

def node_text(src: bytes, node) -> str:
    return src[node.start_byte:node.end_byte].decode('utf-8')


def extract_type(node, src: bytes) -> dict:
    kind_map = {
        "class_declaration": "class",
        "interface_declaration": "interface",
        "enum_declaration": "enum",
        "record_declaration": "record"
    }
    kind = kind_map.get(node.type, "unknown")

    name = None
    extends = None
    implements = []
    fields = []
    methods = []
    nested = []

    for child in node.children:
        if child.type == "identifier":
            name = node_text(src, child)
        elif child.type == "superclass":
            extends = node_text(src, child)
        elif child.type == "super_interfaces":
            implements.append(node_text(src, child))
        elif child.type in ("class_body", "interface_body", "enum_body", "record_body"):
            for member in child.children:
                if member.type == "field_declaration":
                    fields.append(node_text(src, member))
                elif member.type == "method_declaration":
                    methods.append(node_text(src, member))
                elif member.type in kind_map:
                    nested.append(extract_type(member, src))

    return {
        "kind": kind,
        "name": name,
        "extends": extends,
        "implements": implements,
        "fields": fields,
        "methods": methods,
        "nested": nested
    }


def extract_types(tree, src: bytes) -> List[dict]:
    root = tree.root_node
    types = []
    for child in root.children:
        if child.type in ("class_declaration", "interface_declaration", "enum_declaration", "record_declaration"):
            types.append(extract_type(child, src))
    return types


# ------------------------ Markdown Renderer ---------------------------

def render_markdown(types: List[dict]) -> str:
    lines: List[str] = []
    for t in types:
        lines.extend(render_type_md(t, level=2))
    return "\n".join(lines)


def render_type_md(t: dict, level: int = 2) -> List[str]:
    lines: List[str] = []
    header = '#' * level + f" {t['kind'].capitalize()}: {t['name']}"
    lines.append(header)
    if t.get('extends'):
        lines.append(f"**Extends:** {t['extends']}")
    if t.get('implements'):
        lines.append(f"**Implements:** {', '.join(t['implements'])}")

    if t.get('fields'):
        lines.append('\n### Fields')
        for f in t['fields']:
            lines.append(f"- `{f}`")

    if t.get('methods'):
        lines.append('\n### Methods')
        for m in t['methods']:
            lines.append(f"- `{m}`")

    if t.get('nested'):
        lines.append('\n---\n')
        for nt in t['nested']:
            lines.extend(render_type_md(nt, level=level+1))

    lines.append('\n')
    return lines


# ------------------------ Main processing -----------------------------

def process_java_source(src: str) -> List[dict]:
    tree = parser.parse(src.encode('utf-8'))
    return extract_types(tree, src.encode('utf-8'))


def main(argv):
    parser_arg = argparse.ArgumentParser(description='Extract Java metadata and render Markdown (tree-sitter)')
    parser_arg.add_argument('input', help='Path to Java source file')
    parser_arg.add_argument('-o', '--output', help='Output Markdown file (default stdout)')
    args = parser_arg.parse_args(argv)

    src = read_file(args.input)
    types = process_java_source(src)
    md = render_markdown(types)

    if args.output:
        with open(args.output, 'w', encoding='utf-8') as f:
            f.write(md)
        print(f"Wrote documentation to {args.output}")
    else:
        print(md)


if __name__ == '__main__':
    main(sys.argv[1:])
