"""
Java Metadata Hierarchical Extractor (Python, Tree-sitter version)

This script uses `tree-sitter` with the Java grammar to parse Java source
files and extract a hierarchical representation of types (classes,
interfaces, enums, records), their fields, constructors, methods, and nested types.
It outputs a single JSON file with metadata only (no code text).

Requirements:
- Python 3.8+
- pip install tree-sitter tree-sitter-java

Usage:
    python java_metadata_extractor.py input.java -o output.json

"""
import argparse
import sys
import json
from typing import List
from tree_sitter import Language, Parser

# Load Java grammar (tree-sitter-java must be installed)
Language.build_library(
    'build/my-languages.so',
    [
        'tree-sitter-java'
    ]
)

JAVA_LANGUAGE = Language('build/my-languages.so', 'java')
parser = Parser()
parser.set_language(JAVA_LANGUAGE)


def read_file(path: str) -> str:
    with open(path, "r", encoding="utf-8") as f:
        return f.read()


# ------------------------ Tree Walkers -------------------------------

def node_text(src: bytes, node) -> str:
    return src[node.start_byte:node.end_byte].decode('utf-8')


def extract_parameters(param_node, src: bytes) -> dict:
    """Extract parameter type and name."""
    param_info = {"type": None, "name": None}
    for child in param_node.children:
        if child.type == "type":
            param_info["type"] = node_text(src, child)
        elif child.type == "identifier":
            param_info["name"] = node_text(src, child)
    return param_info


def extract_method(node, src: bytes) -> dict:
    """Extract return type, name, and parameters of a method."""
    method_info = {
        "name": None,
        "return_type": None,
        "parameters": []
    }

    for child in node.children:
        if child.type == "identifier":
            method_info["name"] = node_text(src, child)
        elif child.type == "type":
            method_info["return_type"] = node_text(src, child)
        elif child.type == "formal_parameters":
            for param in child.children:
                if param.type == "formal_parameter":
                    method_info["parameters"].append(extract_parameters(param, src))

    return method_info


def extract_field(member, src: bytes) -> dict:
    """Extract field metadata with type and name."""
    field_type, field_name = None, None
    for fchild in member.children:
        if fchild.type == "type":
            field_type = node_text(src, fchild)
        elif fchild.type == "variable_declarator":
            for sub in fchild.children:
                if sub.type == "identifier":
                    field_name = node_text(src, sub)
    return {"name": field_name, "type": field_type}


def extract_type(node, src: bytes) -> dict:
    kind_map = {
        "class_declaration": "class",
        "interface_declaration": "interface",
        "enum_declaration": "enum",
        "record_declaration": "record"
    }
    kind = kind_map.get(node.type, "unknown")

    name = None
    extends = None
    implements = []
    fields = []
    methods = []
    nested = []

    for child in node.children:
        if child.type == "identifier":
            name = node_text(src, child)
        elif child.type == "superclass":
            extends = node_text(src, child)
        elif child.type == "super_interfaces":
            implements.append(node_text(src, child))
        elif child.type in ("class_body", "interface_body", "enum_body", "record_body"):
            for member in child.children:
                if member.type == "field_declaration":
                    field_meta = extract_field(member, src)
                    if field_meta["name"]:
                        fields.append(field_meta)
                elif member.type == "method_declaration":
                    methods.append(extract_method(member, src))
                elif member.type in kind_map:
                    nested.append(extract_type(member, src))

    return {
        "kind": kind,
        "name": name,
        "extends": extends,
        "implements": implements,
        "fields": fields,
        "methods": methods,
        "nested": nested
    }


def extract_types(tree, src: bytes) -> List[dict]:
    root = tree.root_node
    types = []
    for child in root.children:
        if child.type in ("class_declaration", "interface_declaration", "enum_declaration", "record_declaration"):
            types.append(extract_type(child, src))
    return types


# ------------------------ Main processing -----------------------------

def process_java_source(src: str) -> List[dict]:
    tree = parser.parse(src.encode('utf-8'))
    return extract_types(tree, src.encode('utf-8'))


def main(argv):
    parser_arg = argparse.ArgumentParser(description='Extract Java metadata and output JSON (tree-sitter)')
    parser_arg.add_argument('input', help='Path to Java source file')
    parser_arg.add_argument('-o', '--output', help='Output file path (JSON)', required=True)
    args = parser_arg.parse_args(argv)

    src = read_file(args.input)
    types = process_java_source(src)

    metadata = {"types": types}
    with open(args.output, 'w', encoding='utf-8') as f:
        json.dump(metadata, f, indent=2)
    print(f"Wrote JSON metadata to {args.output}")


if __name__ == '__main__':
    main(sys.argv[1:])
