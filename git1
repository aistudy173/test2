import javalang
import re
from pathlib import Path

def chunk_and_context(state: PipelineState) -> PipelineState:
    class_chunks, method_chunks = [], []
    imports = []

    def fqcn_builder(package, nesting):
        """Helper: build FQCN for nested classes/interfaces/enums."""
        return ".".join(filter(None, [package] + nesting))

    def process_type(type_decl, package, nesting, src, file_path):
        fqcn = fqcn_builder(package, nesting + [type_decl.name])

        # --- Class/Interface/Enum chunk ---
        class_chunks.append({
            "type": type_decl.__class__.__name__.replace("Declaration", "").lower(),
            "fqcn": fqcn,
            "annotations": [getattr(a, "name", str(a)) for a in type_decl.annotations],
            "fields": [
                {
                    "name": d.name,
                    "type": getattr(f.type, "name", None),
                    "initializer": getattr(d, "initializer", None),
                    "modifiers": list(f.modifiers or [])
                }
                for f in getattr(type_decl, "fields", [])
                for d in f.declarators
            ],
            "methods": [m.name for m in getattr(type_decl, "methods", [])],
            "constructors": [c.name for c in getattr(type_decl, "constructors", [])],
            "modifiers": list(type_decl.modifiers or []),
            "source_path": str(file_path)
        })

        # --- Process methods ---
        for m in getattr(type_decl, "methods", []):
            return_type = m.return_type.name if m.return_type else "void"
            params = [f"{p.type.name} {p.name}" for p in m.parameters]

            signature = f"{' '.join(m.modifiers or [])} {return_type} {m.name}({', '.join(params)})"
            if m.throws:
                signature += " throws " + ", ".join(t.name for t in m.throws)

            # Javadoc regex (fallback)
            javadoc = None
            javadoc_match = re.search(
                r"/\*\*((?:.|\n)*?)\*/\s*(?:@\w+\s*)*(?:public|private|protected|static|\s)*\b"
                + re.escape(m.name) + r"\s*\(",
                src,
                re.MULTILINE
            )
            if javadoc_match:
                javadoc = javadoc_match.group(1).strip()

            # Method body
            method_body = None
            if m.body:
                method_body = " ".join(str(stmt) for stmt in m.body)
            else:
                sig_pattern = re.escape(m.name) + r"\s*\(.*?\)\s*\{"
                sig_match = re.search(sig_pattern, src, re.DOTALL)
                if sig_match:
                    start_idx = sig_match.end() - 1
                    brace_count, i = 1, start_idx
                    while i < len(src):
                        if src[i] == "{":
                            brace_count += 1
                        elif src[i] == "}":
                            brace_count -= 1
                            if brace_count == 0:
                                method_body = src[start_idx+1:i].strip()
                                break
                        i += 1

            method_chunks.append({
                "type": "method",
                "fqcn": fqcn,
                "method": m.name,
                "signature": signature,
                "javadoc": javadoc,
                "params": params,
                "throws": [t.name for t in m.throws] if m.throws else [],
                "body": method_body,
                "modifiers": list(m.modifiers or []),
                "source_path": str(file_path)
            })

        # --- Process constructors ---
        for c in getattr(type_decl, "constructors", []):
            params = [f"{p.type.name} {p.name}" for p in c.parameters]
            signature = f"{' '.join(c.modifiers or [])} {c.name}({', '.join(params)})"
            if c.throws:
                signature += " throws " + ", ".join(t.name for t in c.throws)

            method_chunks.append({
                "type": "constructor",
                "fqcn": fqcn,
                "method": c.name,
                "signature": signature,
                "javadoc": None,  # could add regex extraction like methods
                "params": params,
                "throws": [t.name for t in c.throws] if c.throws else [],
                "body": " ".join(str(stmt) for stmt in c.body) if c.body else None,
                "modifiers": list(c.modifiers or []),
                "source_path": str(file_path)
            })

        # --- Process nested types recursively ---
        for nested in getattr(type_decl, "types", []):
            process_type(nested, package, nesting + [type_decl.name], src, file_path)

    # --- Iterate files ---
    for f in Path(state.repo_path).rglob("*.java"):
        src = Path(f).read_text(encoding="utf-8", errors="ignore")

        try:
            tree = javalang.parse.parse(src)
        except Exception as e:
            print(f"Failed to parse {f}: {e}")
            continue

        # Capture imports
        imports.extend([imp.path for imp in tree.imports])

        package = tree.package.name if tree.package else None

        for type_decl in tree.types:
            process_type(type_decl, package, [], src, f)

    # Save to pipeline state
    state.imports = imports
    state.classes = [ClassDoc(**c) for c in class_chunks]
    state.methods = [MethodDoc(**m) for m in method_chunks]
    return state
